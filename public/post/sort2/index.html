<!DOCTYPE html>
<html lang="zh-cn">
    <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="w1ndy">
    <meta name="description" content="w1ndy的个人博客">
    
    
    <link rel="prev" href="https://w1ndyz.github.io/post/sort1/" />
    <link rel="next" href="https://w1ndyz.github.io/post/tcp-why/" />
    <link rel="canonical" href="https://w1ndyz.github.io/post/sort2/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <title>
        
        
            排序算法(二) | W1ndy&#39;s Blog
        
    </title>
    <meta name="title" content="排序算法(二) | W1ndy&#39;s Blog">
    
<link rel="stylesheet" href="/css/main.min.css">


    
    
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/w1ndyz.github.io\/"
    },
    "articleSection" : "post",
    "name" : "排序算法(二)",
    "headline" : "排序算法(二)",
    "description" : "归并排序 快速排序",
    "inLanguage" : "zh-cn",
    "author" : "W1ndy",
    "creator" : "W1ndy",
    "publisher": "W1ndy",
    "accountablePerson" : "W1ndy",
    "copyrightHolder" : "W1ndy",
    "copyrightYear" : "2020",
    "datePublished": "2020-01-29 00:00:00 \u002b0000 UTC",
    "dateModified" : "2020-01-29 00:00:00 \u002b0000 UTC",
    "url" : "https:\/\/w1ndyz.github.io\/post\/sort2\/",
    "wordCount" : "2503",
    "keywords" : [ "algorithm", "W1ndy\u0027s Blog"]
}
</script>

  </head>
    <body class="">
        <div class="wrapper">
            <nav class="navbar">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
    <div class="container">
        
            <div class="navbar-header header-back2home-logo">
                <span class="logo_mark" >>$</span>
                <a href="https://w1ndyz.github.io/">
                    <span class="logo_text" >cd /home/</span>
                    <span class="logo_cursor" ></span>
                </a>
            </div>
        
        <div class="navbar-right">
                
                <span class="menu">
                
                <a class="menu-item" href="/post/" title="">Posts</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <a class="menu-item" href="/about/" title="W1ndy">W1ndy</a>
                
                <span class="divide"></span>
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a>
                </span>
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
     <div class="container">
        <div class="navbar">
            <div class="navbar-header header-logo">
                    <a href="https://w1ndyz.github.io/">W1ndy&#39;s Blog</a>
            </div>
            <div class="navbar-right">
                <div><a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a></div>
                <div class="menu-toggle">
                    <span></span><span></span><span></span>
                </div>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                <nav class="mb-md">
                    
                    
                        <a class="menu-item" href="/post/" title="">
                            <h3>Posts</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/categories/" title="">
                            <h3>Categories</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/tags/" title="">
                            <h3>Tags</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/about/" title="">
                            <h3>About</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/about/" title="W1ndy">
                            <h3>W1ndy</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                </nav>
        </div>
    </div>
</nav>
            <main class="main">
                <div class="container">
                    
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">排序算法(二)</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://w1ndyz.github.io/" rel="author">W1ndy</a> with ♥
                <span class="post-time">
                on <time datetime=2020-01-29 itemprop="datePublished">January 29, 2020</time>
                </span>
                in
                
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        
                        
                        
                          <a href="https://w1ndyz.github.io/categories/%E7%AE%97%E6%B3%95/"> 算法, </a>
                        
                        
                </span>
                <span class="post-word-count">2503 words</span>
        </div>
    </header>

    <div class="post-content">
        

        
        
            
        

        
        
        
        
        

        
        
        

        <h3 id="时间复杂度为onlogn的排序">时间复杂度为O(nlogn)的排序</h3>
<p>排序(一)中讲了冒泡排序，插入排序，选择排序。其中插入排序比冒泡排序更常使用的原因是，插入排序只有1次赋值操作，而冒泡排序有3次。它们3种排序的时间复杂度都是O(n²)。接下来会介绍两种时间复杂度为O(nlogn)的排序算法，即归并排序和快速排序。因为时间复杂度的关系，这两种排序算法被广泛用于大规模的数据排序。</p>
<h4 id="归并排序merge-sort">归并排序(Merge Sort)</h4>
<p>归并排序就是将一个无序数组从中间分成前后两个部分，然后对这两个部分分别进行排序，再将排序好的两个部分合并在一起，这样整个数组就排序完了。下面是排序的过程:</p>
<p><img src="https://raw.githubusercontent.com/w1ndyz/windy-img/master/img/gb-sort.png" alt=""></p>
<p>归并排序使用了分治的思想，即分而治之。归并排序使用了递归的代码，要想写出递归，首先先要分析递归的公式，然后找到终止条件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 递归公式
</span><span style="color:#75715e"></span>merge_sort<span style="color:#f92672">(</span>p<span style="color:#f92672">...</span><span style="color:#a6e22e">r</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> merge<span style="color:#f92672">(</span>merge_sort<span style="color:#f92672">(</span>p<span style="color:#f92672">...</span><span style="color:#a6e22e">q</span><span style="color:#f92672">),</span> merge_sort<span style="color:#f92672">(</span>q<span style="color:#f92672">+</span>1<span style="color:#f92672">...</span><span style="color:#a6e22e">r</span><span style="color:#f92672">))</span>
  
<span style="color:#75715e">// 终止条件
</span><span style="color:#75715e"></span>p <span style="color:#f92672">&gt;=</span> r 不用再继续分解
</code></pre></div><p>解释一下上面的公式，就是假设将p到r的数组进行排序，找到中间值q，分别排序p到q，q+1到r，然后再将结果合并在一起。转换成伪代码如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 归并算法，A是需要排序的数组，n表示数组大小
</span><span style="color:#75715e"></span><span style="color:#a6e22e">merge_sort</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">n</span>) {
  <span style="color:#a6e22e">merge_sort_c</span>(<span style="color:#a6e22e">A</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
}

<span style="color:#75715e">// 递归调用
</span><span style="color:#75715e"></span><span style="color:#a6e22e">merge_sort_c</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">r</span>) {
  <span style="color:#75715e">// 递归终止条件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">r</span> { <span style="color:#66d9ef">return</span> }
  
  <span style="color:#75715e">// 取p到r的中间位置q
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">q</span> = (<span style="color:#a6e22e">p</span><span style="color:#f92672">+</span><span style="color:#a6e22e">r</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
  <span style="color:#75715e">// 分治递归
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">merge_sort_c</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
  <span style="color:#a6e22e">merge_sort_c</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">r</span>)
  <span style="color:#75715e">// 将结果合并
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">p</span><span style="color:#f92672">...</span><span style="color:#a6e22e">r</span>], <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">p</span><span style="color:#f92672">...</span><span style="color:#a6e22e">q</span>], <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1.</span>..<span style="color:#a6e22e">r</span>])
}
</code></pre></div><p>我们如何将A[p&hellip;q]和A[q+1&hellip;r]合并呢？</p>
<p>我们申请一个临时数组 tmp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r]中。过程如图所示:</p>
<p><img src="https://raw.githubusercontent.com/w1ndyz/windy-img/master/img/apr-gb.png" alt=""></p>
<p>转换成伪代码如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">p</span><span style="color:#f92672">...</span><span style="color:#a6e22e">r</span>], <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">p</span><span style="color:#f92672">...</span><span style="color:#a6e22e">q</span>], <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1.</span>..<span style="color:#a6e22e">r</span>]) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// 初始化变量i,j,k
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">new</span> <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0.</span>..<span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>] <span style="color:#75715e">// 申请一个与A[p...r]一样大的数组
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">while</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">r</span> <span style="color:#a6e22e">do</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">j</span>] {
      <span style="color:#a6e22e">tmp</span>[<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>] = <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>]
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#a6e22e">tmp</span>[<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>] = <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>]
    }
  }
  <span style="color:#75715e">// 判断哪个子数组当中有剩余的数据
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">r</span> {
    <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">j</span>
    <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>
  }
  
  <span style="color:#75715e">// 将剩余的数据拷贝到tmp
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">while</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">end</span> <span style="color:#a6e22e">do</span> {
    <span style="color:#a6e22e">tmp</span>[<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>] = <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">start</span><span style="color:#f92672">++</span>]
  }
  
  <span style="color:#75715e">// 将tmp拷贝回A[p...r]中
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">p</span><span style="color:#f92672">+</span><span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">tmp</span>[<span style="color:#a6e22e">i</span>]
  }
}
</code></pre></div><p>归并排序的时间复杂度为什么是O(nlogn)？</p>
<p>假设我们对n个元素进行归并排序的时间为T(n),那么分成两个子数组就是T(n/2)，merge合并也为n，所以可以写成:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">T<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> C  <span style="color:#75715e">// n=1时为常量
</span><span style="color:#75715e"></span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n<span style="color:#f92672">;</span> n <span style="color:#f92672">&gt;</span> 1
</code></pre></div><p>分解一下就是:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">T<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n
  <span style="color:#f92672">=</span> 2<span style="color:#f92672">*(</span>2<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>4<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n<span style="color:#f92672">/</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n <span style="color:#f92672">=</span> 4<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>4<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">*</span>n
  <span style="color:#f92672">=</span> 4<span style="color:#f92672">*(</span>2<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>8<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n<span style="color:#f92672">/</span>4<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> 8<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>8<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 3<span style="color:#f92672">*</span>n
  <span style="color:#f92672">=</span> 8<span style="color:#f92672">*(</span>2<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>16<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> n<span style="color:#f92672">/</span>8<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 3<span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> 16<span style="color:#f92672">*</span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>16<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 4<span style="color:#f92672">*</span>n
  <span style="color:#f92672">......</span>
  <span style="color:#f92672">=</span> 2<span style="color:#f92672">^</span>k <span style="color:#f92672">*</span> T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>2<span style="color:#f92672">^</span>k<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> k <span style="color:#f92672">*</span> n
  
<span style="color:#a6e22e">T</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> T<span style="color:#f92672">(</span>n<span style="color:#f92672">/</span>2<span style="color:#f92672">^</span>k<span style="color:#f92672">)</span>
n<span style="color:#f92672">/</span>2<span style="color:#f92672">^</span>k <span style="color:#f92672">=</span> 1
k <span style="color:#f92672">=</span> log2n
<span style="color:#75715e">// 将k代入上面的公式
</span><span style="color:#75715e"></span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> Cn <span style="color:#f92672">+</span> nlog2n
<span style="color:#75715e">// 用大O标记法
</span><span style="color:#75715e"></span>T<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> nlogn
</code></pre></div><p>归并排序之所以没有快速排序应用广泛，是因为归并排序不是原地排序。它所使用了一个tmp空间存储数据。</p>
<p>归并排序的golang实现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 合并 [l,r] 两部分数据，mid 左半部分的终点，mid + 1 是右半部分的起点
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">l</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">mid</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">r</span> <span style="color:#66d9ef">int</span>) {
   <span style="color:#75715e">// 因为需要直接修改 arr 数据，这里首先复制 [l,r] 的数据到新的数组中，用于赋值操作 
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">r</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
    }
    
   <span style="color:#75715e">// 指向两部分起点
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>
    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mid</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">r</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
       <span style="color:#75715e">// 左边的点超过中点，说明只剩右边的数据
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> &gt; <span style="color:#a6e22e">mid</span> {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">right</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>]
            <span style="color:#a6e22e">right</span><span style="color:#f92672">++</span>
        <span style="color:#75715e">// 右边的数据超过终点，说明只剩左边的数据
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">r</span> {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">left</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>]
            <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
       <span style="color:#75715e">// 左边的数据大于右边的数据，选小的数字
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">left</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">l</span>] &gt; <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">l</span>] {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">l</span>]
            <span style="color:#a6e22e">right</span><span style="color:#f92672">++</span>
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">temp</span>[<span style="color:#a6e22e">left</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">l</span>]
            <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
        }
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">l</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">r</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">r</span> {
        <span style="color:#66d9ef">return</span>
    }
  
    <span style="color:#75715e">// 递归向下
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">l</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
    <span style="color:#a6e22e">MergeSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">mid</span>)
    <span style="color:#a6e22e">MergeSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">r</span>)
    <span style="color:#75715e">// 归并向上
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">mid</span>, <span style="color:#a6e22e">r</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">4</span>}
    <span style="color:#a6e22e">MergeSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>)
}
</code></pre></div><h4 id="快速排序quick-sort">快速排序(Quick Sort)</h4>
<p>乍一看起来，快排和归并是很像的。假如我们还是排序A[p&hellip;r]，我们选择p到r之间的任意一个数为分区点(pivot)。遍历p到r的数据将小于pivot的数放在pivot左边，大于pivot的数放在pivot右边，将pivot放在中间，这样数组p到r就被分成了3部分。即p到q-1小于pivot， 中间是pivot， 右边是q到r大于pivot。</p>
<p><img src="https://raw.githubusercontent.com/w1ndyz/windy-img/master/img/qs.png" alt=""></p>
<p>同样，我们使用递归对左右两边进行排序，直到区间缩小为1，就说明排序完成。递归公式如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 递归公式
</span><span style="color:#75715e"></span>quick_sort<span style="color:#f92672">(</span>p<span style="color:#f92672">...</span><span style="color:#a6e22e">r</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> quick_sort<span style="color:#f92672">(</span>p<span style="color:#f92672">...</span><span style="color:#a6e22e">q</span><span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> quick_sort<span style="color:#f92672">(</span>q<span style="color:#f92672">...</span><span style="color:#a6e22e">r</span><span style="color:#f92672">)</span>
  
<span style="color:#75715e">//终止条件
</span><span style="color:#75715e"></span>p <span style="color:#f92672">&gt;=</span> r
</code></pre></div><p>换成伪代码就是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 快速排序，A是数组，n是数组大小
</span><span style="color:#75715e"></span>quick_sort<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  quick_sort_c<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> n<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>

quick_sort<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">if</span> p <span style="color:#f92672">&gt;=</span> r <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">}</span>
  q <span style="color:#f92672">=</span> partition<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span> <span style="color:#75715e">// 获得pivot(一般情况下，可以获得p到r之间的最后一个元素)
</span><span style="color:#75715e"></span>  quick_sort_c<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> q<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span>
  quick_sort_c<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> q<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]。</p>
<p><img src="https://raw.githubusercontent.com/w1ndyz/windy-img/master/img/qs-pivot.png" alt=""></p>
<p>但是这样和归并一样，申请了新的空间去存储数据，并不是原地排序算法，如果要使partition函数不能占用额外的空间，我们就要这样:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">partition<span style="color:#f92672">(</span>A<span style="color:#f92672">,</span> p <span style="color:#f92672">,</span>r<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  pivot <span style="color:#f92672">:=</span> A<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span>
  i <span style="color:#f92672">:=</span> p
    
  <span style="color:#66d9ef">for</span> j <span style="color:#f92672">:=</span> p<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;=</span> r<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> j <span style="color:#f92672">++</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> A<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> pivot <span style="color:#f92672">{</span>
      swap<span style="color:#f92672">(</span>A<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> A<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span>
      i <span style="color:#f92672">:=</span> i<span style="color:#f92672">+</span>1
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
  
  swap<span style="color:#f92672">(</span>A<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> A<span style="color:#f92672">[</span>r<span style="color:#f92672">])</span>
  retuen i
<span style="color:#f92672">}</span>
</code></pre></div><p>这里的处理有点类似选择排序。我们通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。</p>
<p>下面是整个过程:</p>
<p><img src="https://raw.githubusercontent.com/w1ndyz/windy-img/master/img/qs-partition.png" alt=""></p>
<p>快速排序的golang实现如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">source</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">u</span> {
        <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">u</span>)
        <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">u</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">source</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> { <span style="color:#75715e">//划分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> (
        <span style="color:#a6e22e">pivot</span> = <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">l</span>]
        <span style="color:#a6e22e">left</span> = <span style="color:#a6e22e">l</span>
        <span style="color:#a6e22e">right</span> = <span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
    )
    <span style="color:#66d9ef">for</span> ;<span style="color:#a6e22e">right</span>&lt;<span style="color:#a6e22e">u</span>; <span style="color:#a6e22e">right</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">right</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">pivot</span> {
            <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
            <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">left</span>], <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">right</span>] = <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">right</span>], <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">left</span>]
        }
    }
    <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">l</span>], <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">left</span>] = <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">left</span>], <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">l</span>]
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>}
    <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">s</span>))
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>

    </div>

    <div class="post-copyright">
            
            <p class="copyright-item">
                <span>Author:</span>
                <span>w1ndy </span>
                </p>
            

            
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://w1ndyz.github.io/post/sort2/>https://w1ndyz.github.io/post/sort2/</span>
            </p>
            
            
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>


    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s):
            
            <span class="tag"><a href="https://w1ndyz.github.io/tags/algorithm/">
                    #algorithm</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> ·
                <span><a href="https://w1ndyz.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://w1ndyz.github.io/post/sort1/" class="prev" rel="prev" title="排序算法(一)"><i class="iconfont icon-left"></i>&nbsp;排序算法(一)</a>
        
        
        <a href="https://w1ndyz.github.io/post/tcp-why/" class="next" rel="next" title="为什么TCP3次握手4次挥手?">为什么TCP3次握手4次挥手?&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
            
                <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.bootcss.com/gitalk/1.5.2/gitalk.css">
<script src="https://cdn.bootcss.com/gitalk/1.5.2/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({

        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: location.pathname, 
        distractionFreeMode: false 
    });
    (function () {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>

            
        
    </div>
</article>
                </div>
            </main>
            <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i>
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://w1ndyz.github.io/">w1ndy</a> | </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/Mogeko/Mogege" target="_blank" rel="external nofollow">Mogege</a></span>
    </div>
</footer>






<script defer src="/js/vendor_main.min.js"></script>







<script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script> pangu.spacingPage();</script>





        </div>
    </body>
</html>
